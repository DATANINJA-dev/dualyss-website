# MCP Configuration Merge Patterns

Patterns for merging `.mcp.base.json` (framework MCPs) with `.mcp.local.json` (project MCPs) to produce the final `.mcp.json`. Enables coexistence of framework and custom MCP servers without conflicts.

## File Structure Pattern

### Framework Setup

```
project/
├── .mcp.base.json      ← Framework MCPs (tracked in git, synced with hub)
├── .mcp.local.json     ← Project MCPs (git-ignored, local only)
└── .mcp.json           ← Generated output (git-ignored, result of merge)
```

### Git Configuration

```gitignore
# In .gitignore
.mcp.json           # Generated - never commit
.mcp.local.json     # Local customizations - never commit
```

## Template Examples

### .mcp.base.json (Framework MCPs)

This file is tracked and synced with the hub. Contains standard framework MCPs:

```json
{
  "mcpServers": {
    "serena": {
      "command": "uvx",
      "args": ["serena", "--projects-config", ".serena/projects.yaml"],
      "type": "stdio"
    },
    "github": {
      "command": "npx",
      "args": ["-y", "@modelcontextprotocol/server-github"],
      "type": "stdio",
      "env": {
        "GITHUB_PERSONAL_ACCESS_TOKEN": "${GITHUB_TOKEN}"
      }
    }
  }
}
```

### .mcp.local.json (Project MCPs)

This file is git-ignored. Contains project-specific MCP servers:

```json
{
  "mcpServers": {
    "my-database": {
      "command": "node",
      "args": ["./mcp-servers/database-mcp.js"],
      "type": "stdio",
      "env": {
        "DATABASE_URL": "${DATABASE_URL}"
      }
    },
    "project-api": {
      "command": "python",
      "args": ["-m", "project_mcp.server"],
      "type": "stdio"
    }
  }
}
```

### .mcp.json (Merged Output)

Generated by merging base + local. Never edit directly:

```json
{
  "mcpServers": {
    "serena": {
      "command": "uvx",
      "args": ["serena", "--projects-config", ".serena/projects.yaml"],
      "type": "stdio"
    },
    "github": {
      "command": "npx",
      "args": ["-y", "@modelcontextprotocol/server-github"],
      "type": "stdio",
      "env": {
        "GITHUB_PERSONAL_ACCESS_TOKEN": "${GITHUB_TOKEN}"
      }
    },
    "my-database": {
      "command": "node",
      "args": ["./mcp-servers/database-mcp.js"],
      "type": "stdio",
      "env": {
        "DATABASE_URL": "${DATABASE_URL}"
      }
    },
    "project-api": {
      "command": "python",
      "args": ["-m", "project_mcp.server"],
      "type": "stdio"
    }
  }
}
```

## Deep Merge Algorithm

### RFC 7396 JSON Merge Patch (Adapted)

The merge follows RFC 7396 principles with extensions for our use case:

```
Algorithm: mergeMcpConfigs(base, local)

Input:
  base   - Contents of .mcp.base.json (framework)
  local  - Contents of .mcp.local.json (project)

Output:
  merged - Combined configuration

1. Start with deep copy of base
   result = deepCopy(base)

2. For each key in local:
   2a. If local[key] is null:
       → Delete result[key] (RFC 7396: null = delete)

   2b. If local[key] is object AND result[key] is object:
       → Recursively merge: result[key] = merge(result[key], local[key])

   2c. If local[key] is array:
       → Replace entirely: result[key] = local[key]
       (Arrays are NOT merged element-by-element)

   2d. Otherwise (primitives):
       → Override: result[key] = local[key]

3. Return result
```

### Pseudocode Implementation

```
function deepMerge(base, local):
  // Handle null cases
  if local is null:
    return null  // Signal deletion
  if base is null:
    return deepCopy(local)

  // Start with copy of base
  result = deepCopy(base)

  // Iterate through local keys
  for key in local:
    localValue = local[key]
    baseValue = result[key]

    if localValue is null:
      // RFC 7396: null deletes key
      delete result[key]

    else if isObject(localValue) and not isArray(localValue):
      if isObject(baseValue) and not isArray(baseValue):
        // Recursive merge for nested objects
        result[key] = deepMerge(baseValue, localValue)
      else:
        // Type mismatch: local wins
        result[key] = deepCopy(localValue)

    else if isArray(localValue):
      // Arrays are replaced, not merged
      result[key] = deepCopy(localValue)

    else:
      // Primitive: override with local value
      result[key] = localValue

  return result
```

## Collision Detection

### Server Name Collision Scenarios

| Scenario | Base | Local | Result | Action |
|----------|------|-------|--------|--------|
| Base only | `serena: {...}` | (absent) | `serena: {...}` | Use base |
| Local only | (absent) | `my-db: {...}` | `my-db: {...}` | Use local |
| Both same name, same config | `foo: {cmd: "a"}` | `foo: {cmd: "a"}` | `foo: {cmd: "a"}` | No conflict |
| Both same name, different config | `foo: {cmd: "a"}` | `foo: {cmd: "b"}` | `foo: {cmd: "b"}` | Local wins + WARNING |
| Partial override | `foo: {cmd: "a", env: {X: 1}}` | `foo: {env: {Y: 2}}` | `foo: {cmd: "a", env: {X: 1, Y: 2}}` | Deep merge |
| Explicit deletion | `foo: {...}` | `foo: null` | (deleted) | Remove server |

### Conflict Reporting Format

When same server name exists in both files with different configurations:

```
[WARNING] MCP server collision detected:

Server: serena
├─ Base:  command = "uvx"
├─ Local: command = "python"
└─ Result: Using LOCAL configuration

Reason: Local configuration takes precedence for customization.
To keep base version, remove 'serena' from .mcp.local.json
```

### Collision Detection Logic

```
function detectCollisions(base, local):
  collisions = []

  for serverName in local.mcpServers:
    if serverName in base.mcpServers:
      baseConfig = base.mcpServers[serverName]
      localConfig = local.mcpServers[serverName]

      if localConfig is null:
        // Explicit deletion - not a collision
        continue

      if not deepEqual(baseConfig, localConfig):
        collisions.push({
          server: serverName,
          base: baseConfig,
          local: localConfig,
          resolution: "local_wins"
        })

  return collisions
```

## Missing Files Handling

| Scenario | Behavior | Output |
|----------|----------|--------|
| Both exist | Merge base + local | Combined config |
| Only .mcp.base.json | Use base only | Copy of base |
| Only .mcp.local.json | Use local only | Copy of local |
| Neither exists | Create empty | `{ "mcpServers": {} }` |
| .mcp.base.json empty | Use local | Copy of local |
| .mcp.local.json empty | Use base | Copy of base |

```
function loadAndMerge():
  base = loadJsonOrDefault(".mcp.base.json", { mcpServers: {} })
  local = loadJsonOrDefault(".mcp.local.json", { mcpServers: {} })

  return deepMerge(base, local)
```

## Validation Rules

Before writing .mcp.json, validate the merged output:

| Rule | Check | Error Code |
|------|-------|------------|
| Valid JSON | Output parses as JSON | E406 |
| Has mcpServers | Top-level `mcpServers` key exists | E407 |
| Server has command | Each server has `command` field | E408 |
| Server has type | Each server has `type` field (stdio/sse) | E409 |
| Valid type value | `type` is one of: stdio, sse | E410 |
| No circular refs | No circular references in config | E411 |

### Validation Pseudocode

```
function validateMcpConfig(config):
  errors = []

  // Check structure
  if not isObject(config):
    errors.push(E406("Root must be object"))
    return errors

  if "mcpServers" not in config:
    errors.push(E407("Missing mcpServers key"))
    return errors

  // Check each server
  for serverName, serverConfig in config.mcpServers:
    if "command" not in serverConfig:
      errors.push(E408("Server '{serverName}' missing command"))

    if "type" not in serverConfig:
      errors.push(E409("Server '{serverName}' missing type"))
    else if serverConfig.type not in ["stdio", "sse"]:
      errors.push(E410("Server '{serverName}' invalid type: {serverConfig.type}"))

  return errors
```

## Real-World Examples

### Example 1: Adding Project Database MCP

**Scenario**: Project needs a custom database MCP alongside framework MCPs.

**Base** (.mcp.base.json):
```json
{
  "mcpServers": {
    "serena": { "command": "uvx", "args": ["serena"], "type": "stdio" }
  }
}
```

**Local** (.mcp.local.json):
```json
{
  "mcpServers": {
    "postgres": { "command": "node", "args": ["pg-mcp.js"], "type": "stdio" }
  }
}
```

**Result** (.mcp.json):
```json
{
  "mcpServers": {
    "serena": { "command": "uvx", "args": ["serena"], "type": "stdio" },
    "postgres": { "command": "node", "args": ["pg-mcp.js"], "type": "stdio" }
  }
}
```

### Example 2: Overriding Framework MCP Config

**Scenario**: Project needs different Serena configuration.

**Base** (.mcp.base.json):
```json
{
  "mcpServers": {
    "serena": {
      "command": "uvx",
      "args": ["serena", "--projects-config", ".serena/projects.yaml"],
      "type": "stdio"
    }
  }
}
```

**Local** (.mcp.local.json):
```json
{
  "mcpServers": {
    "serena": {
      "command": "python",
      "args": ["-m", "serena_custom"],
      "type": "stdio"
    }
  }
}
```

**Result** (.mcp.json):
```json
{
  "mcpServers": {
    "serena": {
      "command": "python",
      "args": ["-m", "serena_custom"],
      "type": "stdio"
    }
  }
}
```

**Warning emitted**:
```
[WARNING] MCP server collision: serena
  Base uses: uvx serena
  Local uses: python -m serena_custom
  → Using local configuration
```

### Example 3: Removing Framework MCP

**Scenario**: Project doesn't need GitHub MCP.

**Base** (.mcp.base.json):
```json
{
  "mcpServers": {
    "serena": { "command": "uvx", "args": ["serena"], "type": "stdio" },
    "github": { "command": "npx", "args": ["@mcp/github"], "type": "stdio" }
  }
}
```

**Local** (.mcp.local.json):
```json
{
  "mcpServers": {
    "github": null
  }
}
```

**Result** (.mcp.json):
```json
{
  "mcpServers": {
    "serena": { "command": "uvx", "args": ["serena"], "type": "stdio" }
  }
}
```

### Example 4: Adding Environment Variables

**Scenario**: Local config adds env vars to existing server.

**Base** (.mcp.base.json):
```json
{
  "mcpServers": {
    "api": {
      "command": "node",
      "args": ["api-mcp.js"],
      "type": "stdio"
    }
  }
}
```

**Local** (.mcp.local.json):
```json
{
  "mcpServers": {
    "api": {
      "env": {
        "API_KEY": "${MY_API_KEY}",
        "DEBUG": "true"
      }
    }
  }
}
```

**Result** (.mcp.json):
```json
{
  "mcpServers": {
    "api": {
      "command": "node",
      "args": ["api-mcp.js"],
      "type": "stdio",
      "env": {
        "API_KEY": "${MY_API_KEY}",
        "DEBUG": "true"
      }
    }
  }
}
```

## Three-Level Merge (v0.33.0)

Extends two-level merge to support user-level configuration from `~/.claude/.mcp.json`.

### File Structure Pattern (Three-Level)

```
~/.claude/                      ← User home directory
└── .mcp.json                   ← User-level MCPs (global preferences)

project/
├── .mcp.base.json              ← Framework MCPs (tracked in git)
├── .mcp.local.json             ← Project MCPs (git-ignored)
└── .mcp.json                   ← Generated output (git-ignored)
```

### Priority Chain

```
┌─────────────────────────────────────────────────────────────────┐
│                     PRIORITY ORDER (Highest → Lowest)            │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│   ┌──────────────────┐                                          │
│   │  project-local   │  ← Priority 3 (Highest - Project wins)   │
│   │ .mcp.local.json  │                                          │
│   └────────┬─────────┘                                          │
│            │ overrides                                          │
│            ▼                                                    │
│   ┌──────────────────┐                                          │
│   │   user-level     │  ← Priority 2 (User preferences)         │
│   │ ~/.claude/.mcp.json│                                        │
│   └────────┬─────────┘                                          │
│            │ overrides                                          │
│            ▼                                                    │
│   ┌──────────────────┐                                          │
│   │    framework     │  ← Priority 1 (Lowest - Base defaults)   │
│   │ .mcp.base.json   │                                          │
│   └──────────────────┘                                          │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

### Three-Level Deep Merge Algorithm

```
Algorithm: mergeThreeLevelMcpConfigs(framework, user, local)

Input:
  framework  - Contents of .mcp.base.json (framework defaults)
  user       - Contents of ~/.claude/.mcp.json (user preferences)
  local      - Contents of .mcp.local.json (project overrides)

Output:
  merged     - Combined configuration with source tracking

1. Start with framework as base
   result = deepCopy(framework)
   sources = trackSources(framework, "framework")

2. Apply user-level overrides
   result = deepMerge(result, user)
   sources = updateSources(sources, user, "user")

3. Apply project-local overrides (highest priority)
   result = deepMerge(result, local)
   sources = updateSources(sources, local, "local")

4. Attach source metadata (optional, for verbose output)
   result._sources = sources

5. Return result
```

### Three-Level Pseudocode Implementation

```
function mergeThreeLevel(framework, user, local):
  sources = {}

  // Phase 1: Start with framework
  result = { mcpServers: {} }

  for serverName, config in framework.mcpServers:
    result.mcpServers[serverName] = deepCopy(config)
    sources[serverName] = { source: "framework", priority: 1 }

  // Phase 2: Apply user-level (if exists)
  if user and user.mcpServers:
    for serverName, userConfig in user.mcpServers:
      if userConfig is null:
        // RFC 7396: null deletes
        delete result.mcpServers[serverName]
        sources[serverName] = { source: "user", priority: 2, action: "deleted" }

      else if serverName in result.mcpServers:
        // Collision: user overrides framework
        result.mcpServers[serverName] = deepMerge(
          result.mcpServers[serverName],
          userConfig
        )
        sources[serverName] = { source: "user", priority: 2, override: "framework" }

      else:
        // New server from user
        result.mcpServers[serverName] = deepCopy(userConfig)
        sources[serverName] = { source: "user", priority: 2 }

  // Phase 3: Apply project-local (highest priority)
  if local and local.mcpServers:
    for serverName, localConfig in local.mcpServers:
      if localConfig is null:
        // RFC 7396: null deletes
        delete result.mcpServers[serverName]
        previousSource = sources[serverName]?.source or "none"
        sources[serverName] = { source: "local", priority: 3, action: "deleted", override: previousSource }

      else if serverName in result.mcpServers:
        // Collision: local overrides user or framework
        previousSource = sources[serverName].source
        result.mcpServers[serverName] = deepMerge(
          result.mcpServers[serverName],
          localConfig
        )
        sources[serverName] = { source: "local", priority: 3, override: previousSource }

      else:
        // New server from local
        result.mcpServers[serverName] = deepCopy(localConfig)
        sources[serverName] = { source: "local", priority: 3 }

  return { config: result, sources: sources }
```

### Three-Level Collision Scenarios

| Scenario | Framework | User | Local | Result | Source |
|----------|-----------|------|-------|--------|--------|
| Framework only | `serena: {...}` | (absent) | (absent) | `serena: {...}` | framework |
| User only | (absent) | `my-mcp: {...}` | (absent) | `my-mcp: {...}` | user |
| Local only | (absent) | (absent) | `proj-mcp: {...}` | `proj-mcp: {...}` | local |
| User overrides framework | `foo: {cmd: "a"}` | `foo: {cmd: "b"}` | (absent) | `foo: {cmd: "b"}` | user (overrides framework) |
| Local overrides user | (absent) | `bar: {cmd: "a"}` | `bar: {cmd: "b"}` | `bar: {cmd: "b"}` | local (overrides user) |
| Local overrides all | `baz: {cmd: "a"}` | `baz: {cmd: "b"}` | `baz: {cmd: "c"}` | `baz: {cmd: "c"}` | local (overrides user) |
| User deletes framework | `foo: {...}` | `foo: null` | (absent) | (deleted) | user (deleted) |
| Local deletes user's | (absent) | `bar: {...}` | `bar: null` | (deleted) | local (deleted) |
| Local restores deleted | `foo: {...}` | `foo: null` | `foo: {cmd: "new"}` | `foo: {cmd: "new"}` | local |

### User-Level Path Detection

Cross-platform detection of user home directory:

```
function getUserLevelPath():
  // Windows
  if platform == "win32":
    userHome = getEnv("USERPROFILE")
    if not userHome:
      userHome = getEnv("HOMEDRIVE") + getEnv("HOMEPATH")
    return userHome + "\\.claude\\.mcp.json"

  // Unix (macOS, Linux)
  else:
    userHome = getEnv("HOME")
    return userHome + "/.claude/.mcp.json"
```

### Graceful Degradation

User-level errors are **non-fatal** - the merge continues with two levels:

| Error | Code | Behavior |
|-------|------|----------|
| File not found | E412 | Info: proceed with two-level merge |
| Permission denied | E413 | Warning: proceed with two-level merge |
| Invalid JSON | E414 | Warning: proceed with two-level merge |

```
function loadUserLevel():
  try:
    path = getUserLevelPath()
    if not exists(path):
      return { exists: false, config: null }

    content = readFile(path)
    config = parseJSON(content)
    return { exists: true, config: config }

  catch PermissionError:
    warn(E413, "Cannot read user-level config: permission denied")
    return { exists: false, config: null, error: "permission" }

  catch JSONParseError:
    warn(E414, "User-level config has invalid JSON")
    return { exists: false, config: null, error: "invalid_json" }
```

### Three-Level Collision Reporting

When three levels are involved, show the full chain:

```
[WARNING] MCP server collision detected:

Server: serena
├─ Framework: command = "uvx"         (priority 1)
├─ User:      command = "docker"      (priority 2, overrides framework)
├─ Local:     command = "python"      (priority 3, overrides user)
└─ Result: Using LOCAL configuration

Reason: Project-local configuration has highest priority.
```

### Three-Level Examples

#### Example 1: All Three Sources

**User** (~/.claude/.mcp.json):
```json
{
  "mcpServers": {
    "my-global-tool": { "command": "global-tool", "type": "stdio" },
    "serena": { "args": ["--verbose"] }
  }
}
```

**Framework** (.mcp.base.json):
```json
{
  "mcpServers": {
    "serena": { "command": "uvx", "args": ["serena"], "type": "stdio" },
    "github": { "command": "npx", "args": ["@mcp/github"], "type": "stdio" }
  }
}
```

**Local** (.mcp.local.json):
```json
{
  "mcpServers": {
    "project-db": { "command": "node", "args": ["db.js"], "type": "stdio" }
  }
}
```

**Result** (.mcp.json):
```json
{
  "mcpServers": {
    "serena": { "command": "uvx", "args": ["--verbose"], "type": "stdio" },
    "github": { "command": "npx", "args": ["@mcp/github"], "type": "stdio" },
    "my-global-tool": { "command": "global-tool", "type": "stdio" },
    "project-db": { "command": "node", "args": ["db.js"], "type": "stdio" }
  }
}
```

**Sources**:
| Server | Source | Notes |
|--------|--------|-------|
| serena | user | Args overridden by user, command from framework |
| github | framework | No overrides |
| my-global-tool | user | User's global preference |
| project-db | local | Project-specific |

#### Example 2: User Deletes, Local Restores

**Framework** (.mcp.base.json):
```json
{
  "mcpServers": {
    "github": { "command": "npx", "args": ["@mcp/github"], "type": "stdio" }
  }
}
```

**User** (~/.claude/.mcp.json):
```json
{
  "mcpServers": {
    "github": null
  }
}
```

**Local** (.mcp.local.json):
```json
{
  "mcpServers": {
    "github": { "command": "gh-mcp", "args": ["custom"], "type": "stdio" }
  }
}
```

**Result** (.mcp.json):
```json
{
  "mcpServers": {
    "github": { "command": "gh-mcp", "args": ["custom"], "type": "stdio" }
  }
}
```

**Explanation**: User deleted GitHub MCP globally, but this project needs it with custom config. Local wins.

#### Example 3: Project Excludes User-Level

When running with `--exclude-user-level` flag:

**Result**: Falls back to two-level merge (framework + local only)

This is useful when:
- User-level config is known to conflict
- Project needs isolated configuration
- Testing framework defaults

## Merge Command Pattern

The `/sync-mcp-merge` command (TASK-089, extended TASK-100) implements:

```
/sync-mcp-merge [--dry-run] [--verbose] [--include-user-level] [--exclude-user-level]

Options:
  --dry-run              Show what would be merged without writing
  --verbose              Show collision details and merge decisions
  --include-user-level   Force include user-level config (skip prompt)
  --exclude-user-level   Force exclude user-level config (two-level only)

Sources (priority order):
  1. .mcp.base.json       (framework - lowest)
  2. ~/.claude/.mcp.json  (user-level - middle, if detected)
  3. .mcp.local.json      (project - highest)

Output:
  Writes merged config to .mcp.json
  Reports any collisions with source attribution
  Validates output before writing
```
